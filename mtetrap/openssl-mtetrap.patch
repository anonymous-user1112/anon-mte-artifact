diff --git a/apps/lib/apps.c b/apps/lib/apps.c
index a632b0cf..d4d83612 100644
--- a/apps/lib/apps.c
+++ b/apps/lib/apps.c
@@ -2776,28 +2776,28 @@ double app_tminterval(int stop, int usertime)
     return ret;
 }
 
-#elif defined(_SC_CLK_TCK)      /* by means of unistd.h */
-# include <sys/times.h>
-
-double app_tminterval(int stop, int usertime)
-{
-    double ret = 0;
-    struct tms rus;
-    clock_t now = times(&rus);
-    static clock_t tmstart;
-
-    if (usertime)
-        now = rus.tms_utime;
-
-    if (stop == TM_START) {
-        tmstart = now;
-    } else {
-        long int tck = sysconf(_SC_CLK_TCK);
-        ret = (now - tmstart) / (double)tck;
-    }
-
-    return ret;
-}
+// #elif defined(_SC_CLK_TCK)      /* by means of unistd.h */
+// # include <sys/times.h>
+//
+// double app_tminterval(int stop, int usertime)
+// {
+//     double ret = 0;
+//     struct tms rus;
+//     clock_t now = times(&rus);
+//     static clock_t tmstart;
+//
+//     if (usertime)
+//         now = rus.tms_utime;
+//
+//     if (stop == TM_START) {
+//         tmstart = now;
+//     } else {
+//         long int tck = sysconf(_SC_CLK_TCK);
+//         ret = (now - tmstart) / (double)tck;
+//     }
+//
+//     return ret;
+// }
 
 #else
 # include <sys/time.h>
diff --git a/apps/openssl.c b/apps/openssl.c
index a3056c79..8ed0aba1 100644
--- a/apps/openssl.c
+++ b/apps/openssl.c
@@ -58,9 +58,9 @@ static void warn_deprecated(const FUNCTION *fp)
 static int apps_startup(void)
 {
     const char *use_libctx = NULL;
-#ifdef SIGPIPE
-    signal(SIGPIPE, SIG_IGN);
-#endif
+// #ifdef SIGPIPE
+//     signal(SIGPIPE, SIG_IGN);
+// #endif
 
     /* Set non-default library initialisation settings */
     if (!OPENSSL_init_ssl(OPENSSL_INIT_ENGINE_ALL_BUILTIN
diff --git a/apps/speed.c b/apps/speed.c
index 1113d775..675f7988 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -33,7 +33,8 @@
 #include <openssl/crypto.h>
 #include <openssl/rand.h>
 #include <openssl/err.h>
-#include <openssl/evp.h>
+// #include <openssl/evp.h>
+#include "crypto/evp.h"
 #include <openssl/objects.h>
 #include <openssl/core_names.h>
 #include <openssl/async.h>
@@ -86,6 +87,14 @@
 # define RSA_DEFAULT_PRIME_NUM 2
 #endif
 
+#if defined(ENABLE_MTE_SIG_WP) || defined(ENABLE_MTE_KMOD_WP) || defined(ENABLE_MPROT_WP)
+#include "../../mtetrap_module.h"
+#include "../../mtetrap_recovery.h"
+#endif
+#if defined(ENABLE_DR_WP)
+#include "../../dynamorio/drwatchpoint.h"
+#endif
+
 typedef struct openssl_speed_sec_st {
     int sym;
     int rsa;
@@ -126,17 +135,17 @@ static const int aead_lengths_list[] = {
 
 #ifdef SIGALRM
 
-static void alarmed(int sig)
-{
-    signal(SIGALRM, alarmed);
-    run = 0;
-}
+// static void alarmed(int sig)
+// {
+//     signal(SIGALRM, alarmed);
+//     run = 0;
+// }
 
 static double Time_F(int s)
 {
     double ret = app_tminterval(s, usertime);
-    if (s == STOP)
-        alarm(0);
+    // if (s == STOP)
+    //     alarm(0);
     return ret;
 }
 
@@ -825,6 +834,9 @@ static int EVP_Update_loop_aead(void *args)
 
 static long rsa_c[RSA_NUM][2];  /* # RSA iteration test */
 
+static int rsa_sign_iters;
+static int rsa_verify_iters;
+
 static int RSA_sign_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
@@ -834,7 +846,7 @@ static int RSA_sign_loop(void *args)
     EVP_PKEY_CTX **rsa_sign_ctx = tempargs->rsa_sign_ctx;
     int ret, count;
 
-    for (count = 0; COND(rsa_c[testnum][0]); count++) {
+    for (count = 0; count < rsa_sign_iters; count++) {
         *rsa_num = tempargs->buflen;
         ret = EVP_PKEY_sign(rsa_sign_ctx[testnum], buf2, rsa_num, buf, 36);
         if (ret <= 0) {
@@ -856,7 +868,7 @@ static int RSA_verify_loop(void *args)
     EVP_PKEY_CTX **rsa_verify_ctx = tempargs->rsa_verify_ctx;
     int ret, count;
 
-    for (count = 0; COND(rsa_c[testnum][1]); count++) {
+    for (count = 0; count < rsa_verify_iters; count++) {
         ret = EVP_PKEY_verify(rsa_verify_ctx[testnum], buf2, rsa_num, buf, 36);
         if (ret <= 0) {
             BIO_printf(bio_err, "RSA verify failure\n");
@@ -1874,7 +1886,7 @@ int speed_main(int argc, char **argv)
                    "instead of user CPU time.\n");
 
 #if SIGALRM > 0
-    signal(SIGALRM, alarmed);
+    // signal(SIGALRM, alarmed);
 #endif
 
     if (doit[D_MD2]) {
@@ -2348,6 +2360,19 @@ skip_hmac:
         if (RAND_bytes(loopargs[i].buf, 36) <= 0)
             goto end;
 
+#ifdef ENABLE_MTE_SIG_WP
+    fprintf(stdout, "MTETRAP-SSL: install signal based recovery\n");
+    install_signal_based_recovery();
+#elif ENABLE_MTE_KMOD_WP
+    fprintf(stdout, "MTETRAP-SSL: install module based recovery\n");
+    install_module_based_recovery();
+#elif ENABLE_MPROT_WP
+    fprintf(stdout, "MTETRAP-SSL: install mprotect based recovery\n");
+    install_mprotect_based_recovery();
+#elif ENABLE_DR_WP
+    fprintf(stdout, "MTETRAP-SSL: install dynamorio based recovery\n");
+    install_dr_based_recovery();
+#endif
     for (testnum = 0; testnum < RSA_NUM; testnum++) {
         EVP_PKEY *rsa_key = NULL;
         int st = 0;
@@ -2386,6 +2411,19 @@ skip_hmac:
                                  &loopargs[i].sigsize,
                                  loopargs[i].buf, 36) <= 0)
                 st = 0;
+            // add watchpoint
+#ifdef ENABLE_MTE_SIG_WP
+            // add_mte_data_watchpoint(loopargs[i].rsa_sign_ctx[testnum], sizeof(EVP_PKEY_CTX));
+            add_mte_data_watchpoint(loopargs[i].buf2, loopargs[i].sigsize);
+#elif ENABLE_MTE_KMOD_WP
+            // add_mte_data_watchpoint(loopargs[i].rsa_sign_ctx[testnum], sizeof(EVP_PKEY_CTX));
+            add_mte_data_watchpoint(loopargs[i].buf2, loopargs[i].sigsize);
+#elif ENABLE_MPROT_WP
+            // add_mprotect_data_watchpoint(loopargs[i].rsa_sign_ctx[testnum], sizeof(EVP_PKEY_CTX));
+            add_mprotect_data_watchpoint(loopargs[i].buf2, loopargs[i].sigsize);
+#elif ENABLE_DR_WP
+            add_dr_data_watchpoint(loopargs[i].buf2, loopargs[i].sigsize);
+#endif
         }
         if (!st) {
             BIO_printf(bio_err,
@@ -2397,16 +2435,28 @@ skip_hmac:
                                rsa_c[testnum][0], rsa_keys[testnum].bits,
                                seconds.rsa);
             /* RSA_blinding_on(rsa_key[testnum],NULL); */
+            rsa_sign_iters = 10;
+            run_benchmark(async_jobs, RSA_sign_loop, loopargs); // prep run
+            rsa_sign_iters = 1000;
             Time_F(START);
             count = run_benchmark(async_jobs, RSA_sign_loop, loopargs);
             d = Time_F(STOP);
             BIO_printf(bio_err,
-                       mr ? "+R1:%ld:%d:%.2f\n"
+                       mr ? "+R1:%ld:%d:%.6f\n"
                        : "%ld %u bits private RSA's in %.2fs\n",
                        count, rsa_keys[testnum].bits, d);
             rsa_results[testnum][0] = (double)count / d;
             op_count = count;
         }
+#ifdef ENABLE_MTE_SIG_WP
+        remove_all_mte_data_watchpoints();
+#elif ENABLE_MTE_KMOD_WP
+        remove_all_mte_data_watchpoints();
+#elif ENABLE_MPROT_WP
+        remove_all_mprotect_data_watchpoints();
+#elif ENABLE_DR_WP
+        remove_all_dr_data_watchpoints();
+#endif
 
         for (i = 0; st && i < loopargs_len; i++) {
             loopargs[i].rsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key,
@@ -2418,6 +2468,18 @@ skip_hmac:
                                    loopargs[i].sigsize,
                                    loopargs[i].buf, 36) <= 0)
                 st = 0;
+#ifdef ENABLE_MTE_SIG_WP
+            // add_mte_data_watchpoint(loopargs[i].rsa_verify_ctx[testnum], sizeof(EVP_PKEY_CTX));
+            add_mte_data_watchpoint(loopargs[i].buf2, loopargs[i].sigsize);
+#elif ENABLE_MTE_KMOD_WP
+            // add_mte_data_watchpoint(loopargs[i].rsa_verify_ctx[testnum], sizeof(EVP_PKEY_CTX));
+            add_mte_data_watchpoint(loopargs[i].buf2, loopargs[i].sigsize);
+#elif ENABLE_MPROT_WP
+            // add_mprotect_data_watchpoint(loopargs[i].rsa_verify_ctx[testnum], sizeof(EVP_PKEY_CTX));
+            add_mprotect_data_watchpoint(loopargs[i].buf2, loopargs[i].sigsize);
+#elif ENABLE_DR_WP
+            add_dr_data_watchpoint(loopargs[i].buf2, loopargs[i].sigsize);
+#endif
         }
         if (!st) {
             BIO_printf(bio_err,
@@ -2428,15 +2490,28 @@ skip_hmac:
             pkey_print_message("public", "rsa",
                                rsa_c[testnum][1], rsa_keys[testnum].bits,
                                seconds.rsa);
+            rsa_verify_iters = 10;
+            run_benchmark(async_jobs, RSA_verify_loop, loopargs); // prep run
+            rsa_verify_iters = 10000;
             Time_F(START);
             count = run_benchmark(async_jobs, RSA_verify_loop, loopargs);
             d = Time_F(STOP);
             BIO_printf(bio_err,
-                       mr ? "+R2:%ld:%d:%.2f\n"
+                       mr ? "+R2:%ld:%d:%.6f\n"
                        : "%ld %u bits public RSA's in %.2fs\n",
                        count, rsa_keys[testnum].bits, d);
             rsa_results[testnum][1] = (double)count / d;
         }
+        // remove watchpoint
+#ifdef ENABLE_MTE_SIG_WP
+        remove_all_mte_data_watchpoints();
+#elif ENABLE_MTE_KMOD_WP
+        remove_all_mte_data_watchpoints();
+#elif ENABLE_MPROT_WP
+        remove_all_mprotect_data_watchpoints();
+#elif ENABLE_DR_WP
+        remove_all_dr_data_watchpoints();
+#endif
 
         if (op_count <= 1) {
             /* if longer than 10s, don't do any more */
@@ -2444,6 +2519,19 @@ skip_hmac:
         }
         EVP_PKEY_free(rsa_key);
     }
+#ifdef ENABLE_MTE_SIG_WP
+    fprintf(stdout, "MTETRAP-SSL: uninstall signal based recovery\n");
+    uninstall_signal_based_recovery();
+#elif ENABLE_MTE_KMOD_WP
+    fprintf(stdout, "MTETRAP-SSL: uninstall module based recovery\n");
+    uninstall_module_based_recovery();
+#elif ENABLE_MPROT_WP
+    fprintf(stdout, "MTETRAP-SSL: uninstall mprotect based recovery\n");
+    uninstall_mprotect_based_recovery();
+#elif ENABLE_DR_WP
+    fprintf(stdout, "MTETRAP-SSL: uninstall dynamorio based recovery\n");
+    uninstall_dr_based_recovery();
+#endif
 
     for (testnum = 0; testnum < DSA_NUM; testnum++) {
         EVP_PKEY *dsa_key = NULL;
@@ -3394,8 +3482,8 @@ static void pkey_print_message(const char *str, const char *str2, long num,
                mr ? "+DTP:%d:%s:%s:%d\n"
                : "Doing %u bits %s %s's for %ds: ", bits, str, str2, tm);
     (void)BIO_flush(bio_err);
-    run = 1;
-    alarm(tm);
+    // run = 1;
+    // alarm(tm);
 }
 
 static void print_result(int alg, int run_no, int count, double time_used)
diff --git a/crypto/asn1/charmap.h b/crypto/asn1/charmap.h
index ac1eb076..543fd125 100644
--- a/crypto/asn1/charmap.h
+++ b/crypto/asn1/charmap.h
@@ -2,7 +2,7 @@
  * WARNING: do not edit!
  * Generated by crypto/asn1/charmap.pl
  *
- * Copyright 2000-2021 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2000-2024 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
diff --git a/crypto/bn/bn_prime.h b/crypto/bn/bn_prime.h
index 8a859ac0..2cd3f07b 100644
--- a/crypto/bn/bn_prime.h
+++ b/crypto/bn/bn_prime.h
@@ -2,7 +2,7 @@
  * WARNING: do not edit!
  * Generated by crypto/bn/bn_prime.pl
  *
- * Copyright 1998-2021 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1998-2024 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
diff --git a/crypto/conf/conf_def.h b/crypto/conf/conf_def.h
index 1f66a58e..439fc36c 100644
--- a/crypto/conf/conf_def.h
+++ b/crypto/conf/conf_def.h
@@ -2,7 +2,7 @@
  * WARNING: do not edit!
  * Generated by crypto/conf/keysets.pl
  *
- * Copyright 1995-2021 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2024 The OpenSSL Project Authors. All Rights Reserved.
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
  * in the file LICENSE in the source distribution or at
diff --git a/crypto/objects/obj_dat.h b/crypto/objects/obj_dat.h
index 59d15611..7e4b2b66 100644
--- a/crypto/objects/obj_dat.h
+++ b/crypto/objects/obj_dat.h
@@ -2,7 +2,7 @@
  * WARNING: do not edit!
  * Generated by crypto/objects/obj_dat.pl
  *
- * Copyright 1995-2022 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2024 The OpenSSL Project Authors. All Rights Reserved.
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
  * in the file LICENSE in the source distribution or at
diff --git a/crypto/objects/obj_xref.h b/crypto/objects/obj_xref.h
index 21a193ee..c57b0331 100644
--- a/crypto/objects/obj_xref.h
+++ b/crypto/objects/obj_xref.h
@@ -2,7 +2,7 @@
  * WARNING: do not edit!
  * Generated by objxref.pl
  *
- * Copyright 1998-2021 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1998-2024 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
diff --git a/fuzz/oids.txt b/fuzz/oids.txt
index 36c79212..57d23de9 100644
--- a/fuzz/oids.txt
+++ b/fuzz/oids.txt
@@ -1,7 +1,7 @@
 # WARNING: do not edit!
 # Generated by fuzz/mkfuzzoids.pl
 #
-# Copyright 2020-2022 The OpenSSL Project Authors. All Rights Reserved.
+# Copyright 2020-2024 The OpenSSL Project Authors. All Rights Reserved.
 #
 # Licensed under the Apache License 2.0 (the "License").  You may not use
 # this file except in compliance with the License.  You can obtain a copy
diff --git a/include/openssl/obj_mac.h b/include/openssl/obj_mac.h
index 0e860276..18d37cd5 100644
--- a/include/openssl/obj_mac.h
+++ b/include/openssl/obj_mac.h
@@ -2,7 +2,7 @@
  * WARNING: do not edit!
  * Generated by crypto/objects/objects.pl
  *
- * Copyright 2000-2021 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2000-2024 The OpenSSL Project Authors. All Rights Reserved.
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
  * in the file LICENSE in the source distribution or at
